{
	"intinput": {
		"prefix": "inti",
		"body": [
			"int(input())"
		],
		"description": "intinputする"
	},
	"for": {
		"prefix": "for",
		"body": [
			"for i in range(${1:}):"
		],
		"description": "for文"
	},
	"mapinput": {
		"prefix": "mai",
		"body": [
			"map(int, input().split())"
		],
		"description": "mapinputする"
	},
	"listinput": {
		"prefix": "lisi",
		"body": [
			"list(map(int, input().split()))"
		],
		"description": "listinputする"
	},
	"input": {
		"prefix": "input()",
		"body": [
			"input()"
		],
		"description": "inputする"
	},
	"print": {
		"prefix": "print",
		"body": [
			"print(${1:})"
		],
		"description": "print"
	},
	"ma": {
		"prefix": "omazinai",
		"body": [
			"import os",
			"import io",
			"input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline"
		],
		"description": "おまじない"
	},
	"lim": {
		"prefix": "lim",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10000000)",
			"input = sys.stdin.readline"
		],
		"description": "再帰するとき"
	},
	"ki": {
		"prefix": "ki",
		"body": [
			"import sys",
			"sys.setrecursionlimit(1000000000)",
			"input = sys.stdin.readline",
			"n = int(input())",
			"es = [[] for i in range(n)]",
			"for i in range(n - 1):",
			"   a, b = map(int, input().split())",
			"   es[a - 1].append(b - 1)",
			"   es[b - 1].append(a - 1)",
			"def dfs(v):",
			"    ${1:}",
			"    return"
		],
		"description": "木の入力"
	},
	"heapq": {
		"prefix": "heapq",
		"body": [
			"from heapq import heappush,heapify,heappop"
		],
		"description": "優先度付きキュー"
	},
	"Counter": {
		"prefix": "counter",
		"body": [
			"from collections import Counter"
		],
		"description": "Counter"
	},
	"itertools": {
		"prefix": "itertools",
		"body": [
			"from itertools import permutations, combinations"
		],
		"description": "順列, 組合せを生成"
	},
	"bisect": {
		"prefix": "bisect",
		"body": [
			"from bisect import bisect_left ,bisect_right",
			"#bisect_left(a,x):a[i]>=xとなるような最小のi.",
			"#昇順ソートされたリストaに昇順を崩さずxを挿入できる位置s(0-index)を返す.",
			"#a=[1,3,5,7,9,11,13,15,17,19]",
			"#s = bisect_left(a,4)",
			"#s=2"
		],
		"description": "lower_bound"
	},
	"deque": {
		"prefix": "deque",
		"body": [
			"from collections import deque "
		],
		"description": "deque"
	},
	"key": {
		"prefix": "key",
		"body": [
			"key=lambda x:x[${1:}]"
		],
		"description": "ソートのkeyを指定"
	},
	"math": {
		"prefix": "math",
		"body": [
			"from math import comb, factorial, gcd, isqrt, perm, exp, log, log2, log10, sqrt, pi, acos, asin, atan ,atan2, cos, sin, tan",
			"from functools import reduce",
			"def gcd_list(numbers):",
			"   return reduce(gcd, numbers)",
			"def lcm(x, y):",
			"   return (x * y) // gcd(x, y)",
			"def lcm_list(numbers):",
			"   return reduce(lcm, numbers, 1)"
		],
		"description": "math いっぱい ver3.8以降"
	},
	"numpy": {
		"prefix": "numpy",
		"body": [
			"import numpy as np"
		],
		"description": "numpy"
	},
	"shousuu": {
		"prefix": "shousuu",
		"body": [
			"print('{:.15f}'.format(${1:})) # 小数第15桁まで表示"
		],
		"description": "ソートのkeyを指定"
	},
	"lru_cache": {
		"prefix": "lru_cache",
		"body": [
			"from functools import lru_cache",
			"@lru_cache(None)"
		],
		"description": "メモ化再帰"
	},
	"defaultdict": {
		"prefix": "defaultdict",
		"body": [
			"from collections import defaultdict",
			"# d = defaultdict(int)で0で初期化",
			"# d = defaultdict(lambda: 100)で100で初期化"
		],
		"description": "辞書"
	},
	"decimal": {
		"prefix": "decimal",
		"body": [
			"from decimal import Decimal,getcontext",
			"getcontext().prec = 100 # 標準は28,精度を調節"
		],
		"description": "decimal"
	},
	"matplotlib": {
		"prefix": "matplotlib",
		"body": [
			"import matplotlib.pylab as plt"
		],
		"description": "matplotlib"
	},
	"random": {
		"prefix": "random",
		"body": [
			"from random import randint"
		],
		"description": "random"
	},
	"numba": {
		"prefix": "numba",
		"body": [
			"from numba import jit, i8, void, b1, u1, f8",
			"# i8:int, void:void, b1:bool, u1:string, f8:float, i8[:]:int配列, f8[:,:]:float二次元配列",
			"@jit(${1:}(${2:}))"
		],
		"description": "numba"
	},
	"marathon": {
		"prefix": "marathon",
		"body": [
			"import sys",
			"from random import randint",
			"from time import time",
			"start = time()",
			"sys.setrecursionlimit(10000000)",
			"input = sys.stdin.readline",
			"def eval_score():",
			"",
			"    return ",
			""
		],
		"description": "marathon"
	},
	"main": {
		"prefix": "main",
		"body": [
			"if __name__ == '__main__':"
		],
		"description": "main"
	},
	"mathpypy": {
		"prefix": "mathpypy",
		"body": [
			"from math import factorial, gcd, exp, log, log2, log10, sqrt, pi, acos, asin, atan ,atan2, cos, sin, tan",
			"from functools import reduce",
			"def gcd_list(numbers):",
			"   return reduce(gcd, numbers)",
			"def lcm(x, y):",
			"   return (x * y) // gcd(x, y)",
			"def lcm_list(numbers):",
			"   return reduce(lcm, numbers, 1)"
		],
		"description": "mathpypy"
	},
	"time": {
		"prefix": "time",
		"body": [
			"from time import time",
			"start = time()"
		],
		"description": "time"
	},
	"True": {
		"prefix": "ture",
		"body": "True",
		"description": "True"
	},
	"False": {
		"prefix": "false",
		"body": "False",
		"description": "False"
	},
	"deepcopy": {
		"prefix": "deepcopy",
		"body": "from copy import copy, deepcopy",
		"description": "deepcopy"
	},
	"LIS": {
		"prefix": "LIS",
		"body": "# seqの単調増加列の長さ\r\n# パラメータ wider_sense:False=狭義(<), True:広義(<=)\r\n\r\ndef LIS(seq, wider_sense=False):\r\n    from bisect import bisect_left, bisect_right\r\n    f = bisect_right if wider_sense else bisect_left\r\n    N = len(seq)\r\n    INF = 1000000000000000000\r\n    dp = [INF] * (N+1)\r\n    for x in seq:\r\n        dp[f(dp, x)] = x\r\n    return f(dp, INF - 1)",
		"description": "最長共通部分列"
	},
	"Segment Tree": {
		"prefix": "Segment",
		"body": "# Segment Tree\r\nclass Segment:\r\n    def __init__(self, N, init_val):\r\n        self.N0 = 2**(N-1).bit_length()\r\n        # 0-indexedで管理\r\n        self.dat = [identity_element]*(2*self.N0)\r\n        # 値を代入\r\n        for i in range(N):\r\n            self.dat[i+self.N0-1]=init_val[i]    \r\n        # 構築\r\n        for i in range(self.N0-2,-1,-1) :\r\n            self.dat[i]=segfunc(self.dat[2*i+1],self.dat[2*i+2]) \r\n\r\n    # k番目の要素の値をxに変更\r\n    def update(self, k, x):\r\n        k += self.N0-1\r\n        self.dat[k] = x\r\n        while k >= 0:\r\n            k = (k-1)//2\r\n            self.dat[k] = segfunc(self.dat[2*k+1], self.dat[2*k+2])\r\n\r\n    # 区間[l,r)の最小値を求める\r\n    def query(self, l, r):\r\n        L = l + self.N0\r\n        R = r + self.N0\r\n        s = identity_element\r\n        # 区間を列挙しながら最小値を求める\r\n        while L < R:\r\n            if R & 1:\r\n                R -= 1\r\n                s = segfunc(s, self.dat[R-1])\r\n            if L & 1:\r\n                s = segfunc(s, self.dat[L-1])\r\n                L += 1\r\n            L >>= 1\r\n            R >>= 1\r\n        return s\r\n\r\n# segfunc : min, +, *, xor, gcd など\r\n# identity_element : 単位元(min:inf, 和:0, 積:1, xor:0, gcd:0)\r\n\r\ndef segfunc(x,y):\r\n    return min(x,y) # 変える\r\nidentity_element = 2**31-1 # 変える",
		"description": "Segment木"
	},
	"Union-Find": {
		"prefix": "unionfind",
		"body": "class UnionFind():\r\n   # 作りたい要素数nで初期化\r\n   # 使用するインスタンス変数の初期化\r\n   def __init__(self, n):\r\n       self.n = n\r\n       # root[x]<0ならそのノードが根かつその値が木の要素数\r\n       # rootノードでその木の要素数を記録する\r\n       self.root = [-1]*(n+1)\r\n       # 木をくっつける時にアンバランスにならないように調整する\r\n       self.rnk = [0]*(n+1)\r\n   # ノードxのrootノードを見つける\r\n   def Find_Root(self, x):\r\n       if(self.root[x] < 0):\r\n           return x\r\n       else:\r\n           # ここで代入しておくことで、後の繰り返しを避ける\r\n           self.root[x] = self.Find_Root(self.root[x])\r\n           return self.root[x]\r\n   # 木の併合、入力は併合したい各ノード\r\n   def Unite(self, x, y):\r\n       # 入力ノードのrootノードを見つける\r\n       x = self.Find_Root(x)\r\n       y = self.Find_Root(y)\r\n       # すでに同じ木に属していた場合\r\n       if(x == y):\r\n           return\r\n       # 違う木に属していた場合rnkを見てくっつける方を決める\r\n       elif(self.rnk[x] > self.rnk[y]):\r\n           self.root[x] += self.root[y]\r\n           self.root[y] = x\r\n       else:\r\n           self.root[y] += self.root[x]\r\n           self.root[x] = y\r\n           # rnkが同じ（深さに差がない場合）は1増やす\r\n           if(self.rnk[x] == self.rnk[y]):\r\n               self.rnk[y] += 1\r\n   # xとyが同じグループに属するか判断\r\n   def isSameGroup(self, x, y):\r\n       return self.Find_Root(x) == self.Find_Root(y)\r\n   # ノードxが属する木のサイズを返す\r\n   def Count(self, x):\r\n       return -self.root[self.Find_Root(x)]\r\n",
		"description": "Union-Find"
	},
	"組み合わせ": {
		"prefix": "combination",
		"body": "#テーブル作るやつ 前処理:O(n*log(mod)), comb(n, k):O(1)\r\n\r\nmod = 10**9+7 #998244353 # 変える\r\ndef table():\r\n    k = 2 * 10 ** 5 + 5  # 変える\r\n    fac = [1] * k\r\n    finv = [1] * k\r\n    inv = [0] * k\r\n    inv[1] = 1\r\n    for i in range(2, k):\r\n        fac[i] = fac[i - 1] * i % mod\r\n        inv[i] = mod - inv[mod % i] * (mod // i) % mod\r\n        finv[i] = finv[i - 1] * inv[i] % mod\r\n    return fac, finv\r\nfac, finv = table()\r\ndef comb(n, k):\r\n    if n < k:\r\n        return 0\r\n    if n < 0 or k < 0:\r\n        return 0\r\n    return fac[n] * (finv[k] * finv[n - k] % mod) % mod",
		"description": "mod組み合わせ"
	},
	"Binary_Indexed_Tree": {
		"prefix": "BIT",
		"body": "class Binary_Indexed_Tree:\r\n    def __init__(self, n):\r\n        \"\"\"\r\n        :param n: 最大の要素数\r\n        \"\"\"\r\n        self.n = n\r\n        self.tree = [0] * (n + 1)\r\n        self.depth = n.bit_length() - 1\r\n \r\n    def sum(self, i):\r\n        \"\"\" 区間[0,i) の総和を求める \"\"\"\r\n        s = 0\r\n        i -= 1\r\n        while i >= 0:\r\n            s += self.tree[i]\r\n            i = (i & (i + 1) )- 1\r\n        return s\r\n \r\n    def built(self, array):\r\n        \"\"\" array を初期値とするBITを構築 \"\"\"\r\n        for i, a in enumerate(array):\r\n            self.add(i, a)\r\n \r\n    def add(self, i, x):\r\n        \"\"\" i 番目の要素に x を足す \"\"\"\r\n        while i < self.n:\r\n            self.tree[i] += x\r\n            i |= i + 1\r\n \r\n    def get(self, i, j):\r\n        \"\"\" 部分区間和 [i, j) \"\"\"\r\n        if i == 0:\r\n            return self.sum(j)\r\n        return self.sum(j) - self.sum(i)\r\n \r\n    def lower_bound(self, x, equal=False):\r\n        \"\"\" (a0+a1+...+ai < x となる最大の i, その時の a0+a1+...+ai )\r\n             a0+a1+...+ai <= x としたい場合は equal = True\r\n             二分探索であるため、ai>=0 を満たす必要がある\"\"\"\r\n        sum_ = 0\r\n        pos = -1  # 1-indexed の時は pos = 0\r\n        if equal:\r\n            for i in range(self.depth, -1, -1):\r\n                k = pos + (1 << i)\r\n                if k < self.n and sum_ + self.tree[k] <= x: # 1-indexed の時は k <= self.n\r\n                    sum_ += self.tree[k]\r\n                    pos += 1 << i\r\n        else:\r\n            for i in range(self.depth, -1, -1):\r\n                k = pos + (1 << i)\r\n                if k < self.n and sum_ + self.tree[k] < x:  # 1-indexed の時は k <= self.n\r\n                    sum_ += self.tree[k]\r\n                    pos += 1 << i\r\n\r\n        return pos, sum_\r\n \r\n    def __getitem__(self, i):\r\n        \"\"\" [a0, a1, a2, ...] \"\"\"\r\n        return self.get(i, i+1)\r\n \r\n    def __iter__(self):\r\n        \"\"\" [a0, a1, a2, ...] \"\"\"\r\n        for i in range(self.n):\r\n            yield self.get(i, i+1)\r\n \r\n    def __str__(self):\r\n        text1 = \" \".join([\"element:            \"] + list(map(str, self)))\r\n        text2 = \" \".join([\"cumsum(1-indexed):  \"] + list(str(self.sum(i)) for i in range(1, self.n + 1)))\r\n        return \"\\n\".join((text1, text2))\r\n\r\n\r\n",
		"description": "Binary_Indexed_Tree"
	}
}